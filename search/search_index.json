{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GO Vast client","text":"<p>The Vast Go client provides a convenient and typed interface for interacting with the VAST Data REST API. It wraps low-level HTTP operations with structured methods and helpers, enabling you to manage different resources.</p>"},{"location":"#vmsconfig-client-configuration","title":"VMSConfig: Client Configuration","text":"<p>The VMSConfig struct defines how the Vast Go client connects to the VMS API server.</p> <p>Configuration example: <pre><code>import (\n    \"time\"\n    \"vast_client/client\"\n)\n\nfunc main() {\n    timeout := 30 * time.Second\n    config := &amp;client.VMSConfig{\n        Host:           \"10.27.40.1\",\n        Port:           443,\n        Username:       \"admin\",\n        Password:       \"123456\",\n        SslVerify:      true,\n        Timeout:        &amp;timeout,\n        MaxConnections: 10,\n        UserAgent:      \"vast-go-client/1.0\",\n        ApiVersion:     \"v5\",\n        BeforeRequestFn: func(ctx context.Context, verb, url string, body io.Reader) error {\n            // Example of BeforeRequest interceptor.\n            // Interceptor takes copy of body so you can read from it safely.\n            log.Printf(\"Sending request: verb=%s, url=%s\", verb, url)\n            if body != nil {\n               bodyBytes, err := io.ReadAll(body)\n                if err != nil { return err }\n                var pretty bytes.Buffer\n                if err = json.Indent(&amp;pretty, bodyBytes, \"\", \"  \"); err == nil {\n                    log.Printf(\"Request JSON:\\n%s\", pretty.String())\n                } else {\n                    log.Printf(\"Request Body:\\n%s\", string(bodyBytes))\n                }\n            }\n            return nil\n        },\n        AfterRequestFn: func(response client.Renderable) (client.Renderable, error) {\n            // Example of AfterRequest interceptor.\n            log.Printf(\"Result:\\n%s\", response.Render())\n            return response, nil\n        },\n    }\n    rest := client.NewVMSRest(config)\n}\n</code></pre></p>"},{"location":"#configuration-parameters","title":"Configuration Parameters","text":"Field Type Description Required Default <code>Host</code> <code>string</code> Hostname or IP of the VMS API server. \u2705 \u2014 <code>Port</code> <code>uint64</code> Port for the API server. \u274c <code>443</code> <code>Username</code> <code>string</code> Username for basic auth (used with <code>Password</code>). \u26a0\ufe0f \u2014 <code>Password</code> <code>string</code> Password for basic auth (used with <code>Username</code>). \u26a0\ufe0f \u2014 <code>ApiToken</code> <code>string</code> Optional bearer token (alternative to username/password). \u26a0\ufe0f \u2014 <code>SslVerify</code> <code>bool</code> Verify SSL certificates when <code>true</code>. \u274c <code>false</code> <code>Timeout</code> <code>*time.Duration</code> HTTP timeout for API requests. If <code>nil</code>, a default is used. \u274c <code>30s</code> <code>MaxConnections</code> <code>int</code> Max concurrent HTTP connections. \u274c <code>10</code> <code>UserAgent</code> <code>string</code> Optional custom <code>User-Agent</code> string for HTTP requests. \u274c <code>vast-go-client</code> <code>BeforeRequestFn</code> <code>func(ctx context.Context, verb, url string, body io.Reader) error</code> Optional hook executed before each request. Useful for logging or mutation. \u274c \u2014 <code>AfterRequestFn</code> <code>func(response Renderable) (Renderable, error)</code> Optional hook executed after receiving a response. Useful for logging or mutation. \u274c \u2014"},{"location":"#vmsrest-entry-point-to-vast-api-resources","title":"VMSRest: Entry Point to VAST API Resources","text":"<p>The <code>VMSRest</code> object serves as the primary interface to interact with the VAST Data API. It acts as a container for multiple subresources, each representing a logical component of the VAST system (e.g., views, volumes, snapshots).</p> <p>You typically initialize it like so:</p> <pre><code>ctx := context.Background()\nconfig := &amp;client.VMSConfig{\n    Host:     \"10.27.40.1\",\n    Username: \"admin\",\n    Password: \"123456\",\n}\n\nrest := client.NewVMSRest(config)\n</code></pre> <p>Subresources The VMSRest object includes multiple subresources (e.g., rest.Views, rest.Quotas, rest.Volumes, etc.).</p> <p>Each subresource has the following standard methods:</p> <ul> <li>List</li> <li>Get</li> <li>GetById</li> <li>Create</li> <li>Update</li> <li>Ensure</li> <li>Delete</li> <li>DeleteById</li> </ul> <p>Note</p> <p>Additionally, a resource can define extra methods to handle \"non-standard\" URLs, such as endpoints that return asynchronous tasks or perform custom operations.</p> <p>Examples: <pre><code>// Create a volume\nresult, err := rest.Volumes.Create(ctx, client.Params{\"name\": \"myvolume\", \"size\": 10 * 512, \"view_id\": 3})\n\nfmt.Println(\"Name -&gt; \", result[\"name\"])\nfmt.Println(\"Uuid -&gt; \", result[\"uuid\"])\nfmt.Println(result.Render())\n</code></pre></p> <pre><code>// Ensure view (Get by name or Create with provided name and additional params):\nparams := client.Params{\"path\": \"/myblock\", \"protocols\": []string{\"BLOCK\"}, \"policy_id\": 1}\nresult, err := rest.Views.Ensure(ctx, \"myview\", params)\n\nfmt.Println(\"Name -&gt; \", result[\"name\"])\nfmt.Println(\"Protocols -&gt; \", result[\"protocols\"])\nfmt.Println(\"Tenant -&gt; \", result[\"tenant_name\"])\nfmt.Println(\"QosPolicy -&gt; \", result[\"qos_policy\"])\nfmt.Println(result.Render())\n</code></pre> <pre><code>// Get Vippool\nresult, err := rest.VipPools.Get(ctx, client.Params{\"name\": \"vippool-1\", \"tenant_id\": 1})\n\nfmt.Println(\"Name -&gt; \", result[\"name\"])\nfmt.Println(\"StartIp -&gt; \", result[\"start_ip\"])\nfmt.Println(\"EndIp -&gt; \", result[\"end_ip\"])\nfmt.Println(result.Render())\n</code></pre> <pre><code>// Delete Quota  (Get quota by search params and if found delete it. Not found is not error condition)\n_, err = rest.Quotas.Delete(ctx, client.Params{\"path__endswith\": \"foobar\"})\n</code></pre> <pre><code>// Delete Quota by ID\n_, err = rest.Quotas.DeleteById(ctx, 25)\n</code></pre>"},{"location":"#working-with-record-render-and-fill","title":"Working with Record: .Render() and .Fill()","text":"<p>Pretty Printing: The Record type includes a <code>.Render</code> method for printing data in a readable tabular format.</p>"},{"location":"#render","title":"Render","text":"<pre><code>fmt.Println(result.Render())\n\nVipPool:\n+------------------------+--------------------------------------+\n| attr                   | value                                |\n+========================+======================================+\n| id                     | 2                                    |\n+------------------------+--------------------------------------+\n| ip_ranges              | [[10.0.0.1 10.0.0.16]]               |\n+------------------------+------------------------------ -------+\n| name                   | vippool-1                            |\n..................\n</code></pre>"},{"location":"#fill","title":"Fill","text":"<p>You can define a Go struct with matching fields and JSON tags to map the API response: <pre><code>type ViewContainer struct {\n    ID       int64  `json:\"id\"`\n    Name     string `json:\"name\"`\n    Path     string `json:\"path\"`\n    TenantID int64  `json:\"tenant_id\"`\n}\n</code></pre></p> <p>Then use <code>.Fill</code> to populate struct from the API result: <pre><code>ctx := context.Background()\nconfig := &amp;client.VMSConfig{\n    Host:     \"10.27.40.1\",\n    Username: \"admin\",\n    Password: \"123456\",\n}\n\nrest := client.NewVMSRest(config)\n\nresult, err := rest.Views.Ensure(ctx, \"myvolume\", client.Params{\n    \"path\":      \"/myblock\",\n    \"protocols\": []string{\"BLOCK\"},\n    \"policy_id\": 1,\n})\nif err != nil {\n    log.Fatal(err)\n}\n\nvar view ViewContainer\nif err := result.Fill(&amp;view); err != nil {  // &lt;- Make sure you passed pointer here\n    log.Fatal(err)\n}\n\nfmt.Println(\"View name:\", view.Name)\nfmt.Println(\"Path:\", view.Path)\nfmt.Println(\"ID:\", view.ID)\nfmt.Println(\"Tenant ID:\", view.TenantID)\n</code></pre></p> <p>Note</p> <p>The struct must have valid json tags for .Fill() to work correctly.</p>"},{"location":"#low-level-client-api-methods","title":"Low level Client API methods","text":"<p>Subresources are being gradually integrated into the <code>VMSRest</code> object. If a specific resource is not yet available, you can use the lower-level Client API methods as a fallback.</p> <p>Rest Session implements 5 methods <pre><code>Get(context.Context, string, io.Reader) (*http.Response, error)\nPost(context.Context, string, io.Reader) (*http.Response, error)\nPut(context.Context, string, io.Reader) (*http.Response, error)\nPatch(context.Context, string, io.Reader) (*http.Response, error)\nDelete(context.Context, string, io.Reader) (*http.Response, error)\n</code></pre></p> <p>Example:</p> <pre><code>ctx := context.Background()\nconfig := &amp;client.VMSConfig{\n    Host:     \"10.27.40.1\",\n    Username: \"admin\",\n    Password: \"123456\",\n}\n\nrest := client.NewVMSRest(config)\n\npath := \"views\"\nquery := \"name=MyView\"\napiVer := \"v5\"\n\n//  Helper to build full url (host/port are taken from config)\nurl, err := rest.BuildUrl(path, query, apiVer)\nif err != nil {\n    log.Fatal(err)\n}\n\nresponse, err := rest.Session.Get(ctx, url, nil)\nif err != nil {\n    log.Fatal(err)\n}\nbody, err := io.ReadAll(response.Body)\nif err != nil {\n    log.Fatal(err)\n}\ndefer response.Body.Close()\nresult := []map[string]any{}\nerr = json.Unmarshal(body, &amp;result)\n</code></pre> <p>Note</p> <p>\"Low level\" methods return *http.Response so you need to read from response and parse it.</p>"},{"location":"for-developers/","title":"For Developers","text":""},{"location":"for-developers/#do-you-want-to-add-new-api-resource","title":"Do you want to add new API resource?","text":"<p>Suppose you want to add a User resource so that it can be queried  using the endpoints <code>&lt;base url&gt;/users</code> for listing and <code>&lt;base url&gt;/users/&lt;id&gt;</code> for retrieving details.</p> <ul> <li>Start by defining a new VastResource named User in the <code>vast_resource.go</code> file.</li> </ul> <pre><code>type User struct {\n    *VastResourceEntry\n}\n</code></pre> <ul> <li>Add new <code>User</code> type to <code>VastResourceType</code> generic type in <code>the vast_resource.go</code> file.</li> </ul> <pre><code>type VastResourceType interface {\n    Version | Quota | View | User // &lt;- Here\n}\n</code></pre> <ul> <li>Declare new <code>Users</code> sub-resource in <code>rest.go</code> file and add resource initialization.</li> </ul> <pre><code>type VMSRest struct {\n    Session     RESTSession\n    resourceMap map[string]VastResource\n\n    Versions          *Version\n    VTasks            *VTask\n    Quotas            *Quota\n    Views             *View\n    VipPools          *VipPool\n    Users             *User  // &lt;- Here\n}\n</code></pre> <pre><code>....\nrest.Quotas = newResource[Quota](rest, \"quotas\", dummyClusterVersion)\nrest.Views = newResource[View](rest, \"views\", dummyClusterVersion)\nrest.VipPools = newResource[VipPool](rest, \"vippools\", dummyClusterVersion)\nrest.Users = newResource[User](rest, \"users\", dummyClusterVersion) // &lt;- Here\n....\n</code></pre> <p>At this point methods <code>List</code>, <code>Get</code>, <code>Delete</code>, <code>Update</code>, <code>Ensure</code>, <code>GetById</code>, <code>DeleteById</code> are available at your disposal.</p> <p>Examples:</p> <p>Create <code>User</code>: <pre><code>result, err := rest.Users.Create(ctx, client.Params{\n    \"name\": \"myUser\",\n    \"uid\":  9999,\n})\n</code></pre></p> <p>Ensure <code>User</code> (Get by name or Create with provided name and additional params): <pre><code>result, err := rest.Users.Ensure(ctx, \"myUser\", client.Params{\"uid\": 9999})\n</code></pre></p> <p>Update <code>User</code>: <pre><code>result, err := rest.Users.Update(ctx, 1, client.Params{\"uid\": 10000})\n</code></pre></p> <p>Get <code>User</code>: <pre><code>result, err := rest.User.Get(ctx, client.Params{\"name\": \"myUser\"})\n</code></pre></p> <p>Get <code>User</code> by id: <pre><code>result, err := rest.Users.GetById(ctx, 1)\n</code></pre></p> <p>Delete <code>User</code> (Get user by search params and if found delete it. Not found is not error condition): <pre><code>result, err := rest.Users.Delete(ctx, client.Params{\"name\": \"myUser\"})\n</code></pre></p> <p>Delete <code>User</code> by id: <pre><code>result, err := rest.Users.DeleteById(ctx, 1)\n</code></pre></p> <p>Note</p> <p>Aforementioned flow covers \"classic\" API resources of form <code>/&lt;resource name&gt;/&lt;id&gt;</code>.  For non-standard APIs you have to define custom methods or use \"Low level API\" (see Overview section)</p>"},{"location":"for-developers/#define-non-standard-method-for-api-resource","title":"Define non-standard method for API Resource","text":"<p>You can define custom methods for API Resource. Good example is <code>UserKey</code> Resource for generating S3 keys. It has 2 custom methods <code>CreateKey</code> and <code>DeleteKey</code></p> <pre><code>type UserKey struct {\n    *VastResourceEntry\n}\n\nfunc (uk *UserKey) CreateKey(ctx context.Context, userId int64) (Record, error) {\n    path := fmt.Sprintf(uk.resourcePath, userId)\n    return request[Record](ctx, uk, http.MethodPost, path, uk.apiVersion, nil, nil)\n}\n\nfunc (uk *UserKey) DeleteKey(ctx context.Context, userId int64, accessKey string) (EmptyRecord, error) {\n    path := fmt.Sprintf(uk.resourcePath, userId)\n    return request[EmptyRecord](ctx, uk, http.MethodDelete, path, uk.apiVersion, nil, Params{\"access_key\": accessKey})\n}\n</code></pre> <p>Warning</p> <p>Main rule: Do not override standard methods Ensure, Get, List, Create, DeleteById etc. Create your own methods like CreateUser, DeleteKey etc.</p> <p>Another good example is <code>BlockHostMapping</code> Resource where specific methods are used to map BlockHosts to Volumes.</p>"},{"location":"for-developers/#requestresponse-interceptors","title":"Request/Response interceptors","text":"<p>API Resources can implement <code>RequestInterceptor</code> interface</p> <p>You can define method <code>beforeRequest</code> for particular resource: <pre><code>beforeRequest(context.Context, verb string, url string, body io.Reader) error\n</code></pre></p> <p>Parameters:</p> <ul> <li>ctx: The request context, useful for deadlines, tracing, or cancellation.</li> <li>verb: The HTTP method (e.g., GET, POST, PUT).</li> <li>url: The URL path being accessed (including query params)</li> <li>body: The request body as an io.Reader, typically containing JSON data.</li> </ul> <p>Or you can define method <code>afterRequest</code>:</p> <pre><code>afterRequest(response Renderable) (Renderable, error)\n</code></pre> <p>Parameters:</p> <ul> <li>response: Resources that implement Renderable interface (Record, RecordSet, EmptyRecord)</li> </ul> <p>At this moment I don't have practical example for <code>beforeRequest</code>. Probably it can be used for logging etc.</p> <p>For <code>afterRequest</code> good example is <code>Snapshot</code> resource:</p> <pre><code>type Snapshot struct {\n    *VastResourceEntry\n}\n\nfunc (s *Snapshot) afterRequest(response Renderable) (Renderable, error) {\n    // List of snapshots is returned under \"results\" key\n    return applyCallbackForRecordUnion[RecordSet](response, func(r Renderable) (Renderable, error) {\n        // This callback is only invoked if response is a RecordSet\n        if rawMap, ok := any(r).(map[string]interface{}); ok {\n            if inner, found := rawMap[\"results\"]; found {\n                if list, ok := inner.([]map[string]any); ok {\n                    return toRecordSet(list)\n                }\n            }\n        }\n        return r, nil\n    })\n}\n</code></pre> <p>Here in case of <code>RecordSet</code> (List endpoint) list of snapshot records are returned under <code>results</code> key. IOW smth like: <pre><code>{\n  \"results\": [\n    {\n      \"name\": \"snapshot1\",  .. other fields\n    },\n    {\n      \"name\": \"snapshot2\" .. other fields\n    }\n  ]\n}\n</code></pre></p> <p>So make sense to get <code>results</code> value and return only it to avoid additional parsing of returned Record.</p>"},{"location":"resources/","title":"Supported Resources","text":"<p>The <code>rest</code> client provides access to the following resources via their respective HTTP subpaths:</p> Resource HTTP Subpath Versions <code>versions</code> VTasks <code>vtasks</code> Quotas <code>quotas</code> Views <code>views</code> VipPools <code>vippools</code> Users <code>users</code> UserKeys <code>users/%d/access_keys</code> Snapshots <code>snapshots</code> BlockHosts <code>blockhosts</code> Volumes <code>volumes</code> BlockHostMappings <code>blockhostvolumes</code> Cnodes <code>cnodes</code> QosPolicies <code>qospolicies</code> DNS <code>dns</code> ViewPolicies <code>viewpolicies</code> Groups <code>groups</code> NIS <code>nis</code> Tenants <code>tenants</code> LDAPs <code>ldaps</code> S3LifeCycleRules <code>s3lifecyclerules</code> ActiveDirectories <code>activedirectory</code> S3Policies <code>s3userpolicies</code> ProtectedPaths <code>protectedpaths</code> GlobalSnapshotStreams <code>globalsnapstreams</code> ReplicationPeers <code>nativereplicationremotetargets</code> ProtectionPolicies <code>protectionpolicies</code> S3ReplicationPeers <code>replicationtargets</code> Realms <code>realms</code> Roles <code>roles</code>"}]}